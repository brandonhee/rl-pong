import numpy as cp

# Source: Garret Walton

def screen_process(screen_input, p_loc, frame_ct, rng_tol, frame_tol=21):
    """ prepro 210x160x3 uint8 frame into 6400 (80x80) 1D float vector.
     The frame_tol is the number of frames to wait before scanning."""
    screen_input = screen_input[35:195]  # crop
    screen_input = screen_input[::2, ::2, 0]  # downsample by factor of 2
    screen_input[screen_input == 144] = 0  # erase background (background type 1)
    screen_input[screen_input == 109] = 0  # erase background (background type 2)
    screen_input[screen_input != 0] = 1  # everything else (paddles, ball) just set to 1

    if frame_ct >= frame_tol:
        if frame_ct < frame_tol + 4:  #  The initial starting frames, when the ball appears.
            ball, direction = get_ball(screen_input, p_loc[0], rng_tol, p_loc[3], initial=True)
        else:
            ball, direction = get_ball(screen_input, p_loc[0], rng_tol, p_loc[3])
        # l_paddle = get_left_paddle(screen_input, p_loc[1])
        l_paddle = list()
        r_paddle = get_right_paddle(screen_input, p_loc[2])
        p_ball = p_loc[0]

    else:
        ball = list()
        l_paddle = list()
        r_paddle = list()
        p_ball = list()
#        direction = list()   # geoff: would this cause direction[0] to return null??
        direction = [0]

    return screen_input.astype(cp.float).ravel(), [ball, l_paddle, r_paddle, p_ball, direction]
    
def follow_the_ball(current_state):
    """Based on current state, returns a recommended action based on relative location of the ball and paddle.
    Always tries to center the paddle in front of the ball. The directional data produces more reliable movement."""
    # Current state consists of [ball, l_paddle, r_paddle, p_ball, direction]
    if not current_state[0]:  # If there is no ball location, heuristic makes no recommendation.
        return 0
    elif not current_state[2]:  # If there is no paddle location, heuristic makes no recommendation.
        return 0

    ball_2 = min(current_state[0])  # Picks the top pixel in the ball list.

    paddle_top = min([i[0] for i in current_state[2]]) # Gets the top pixel of the paddle
    paddle_bottom = max([i[0] for i in current_state[2]])  # Bottom of the paddle

    direction = current_state[4]  # 2 or 3. Last known direction.

    # If the direction provided moves the paddle towards the ball, move towards it.
    if direction[0] == 'NE' or direction[0] == 'NW': #2:
        # print("dir up", end="")
        if ball_2[0] <= paddle_top:
            # print("move")
            return 2
        else:
            # print("Stop")
            return 0
    elif direction[0] == 'E' or  direction[0] == 'SE' or direction[0] == 'SW': #3:
        # print("dir down ", end="")
        if ball_2[0] > paddle_bottom:
            # print("move")
            return 3
        else:
            # print("Stop")
            return 0

    # Otherwise, move towards the ball.
    else:
        # print("dir unk ", end="")
        if ball_2[0] <= 0:
            # print("lost")
            return 0
        elif ball_2[0] + 1 <= paddle_top:
            # print("up")
            return 2
        elif ball_2[0] > paddle_bottom:
            # print("down")
            return 3
        else:
            # print("none")
            return 0

def h_diff_mod(p_up, move_recommend, weight=0.15):
    """This function uses the preset weight to modify the probability generated by the
    neural network. In either case, agreement promotes the movement while disagreement
    damps the probability. The higher the probability, the more likely to move up."""
    if move_recommend == 2:
        return weight * p_up
    elif move_recommend == 3:
        return -weight * p_up
    else:
        return 0
        
def travel_vector(pix, pr_pix):
    """Given two ball pixels, determine ball direction.
    deltaV: positive=down, negative=up
    deltaH: positive=right, negative=left"""
    delta_vert = pix[0] - pr_pix[0]
    delta_hor = pix[1] - pr_pix[1]

    return [delta_vert, delta_hor]


def proximity_alarm(p_ball, rn_tol):
    """This function uses the previous location and the preset tolerance
    to determine if the ball was closing in on a location prone to ball
    loss. Picks the pixel values closest to the top left of the screen."""
    global proximity
    paddle, wall = False, False
    top = min([i[0] for i in p_ball])
    left = min([i[1] for i in p_ball])
    if (top < 10 + rn_tol) or (top > 70 + rn_tol):
        paddle = True
    if (left < 8 + rn_tol) or (left > 60 + rn_tol):
        wall = True
    if wall or paddle:
        proximity = True
    else:
        proximity = False
    return paddle, wall


def center_search(screen, outer_ball_list):
    """Scans a small square in the center of the screen."""
    for i in range(35, 46):
        for j in range(35, 46):
            if screen[i][j] != 0:
                outer_ball_list.append((i, j))
                # print("cs ping")
    return len(outer_ball_list) > 0


def score_area_check(screen, obl):
    """Searches the score area for the ball. The score area is behind
    the paddles. Unused."""
    for i in range(0, 80):
        for j in range(0, 8):
            if screen[i][j] != 0:
                obl.append((-1, -1))
                # print("score ping yay")
                return None
            elif screen[i][j + 72] != 0:
                obl.append((-1, -1))
                # print("score ping boo")
                return None


def omni_search(screen, ball_list, ball, rn_tol):
    """Scans in an area around the last known position of the ball.
    This search is used in the event that directional information
     is not available, or the ball is in a lossy area."""
    finder = False
    point = forty_close(ball_list)
    """These for loops use max and min to ensure the search doesn't leave the
    score area. The rn_tol is used to control the radius of the search."""
    for i in range(max(0, point[0] - rn_tol), min(79, point[0] + rn_tol)):
        for j in range(max(10, point[1] - rn_tol), min(70, point[1] + rn_tol)):
            if screen[i][j] != 0:
                finder = True
                ball.append((i, j))
                # print("found a pixel", end=" ")
                # print(i, j)
                if len(ball) >= 2:  # Short Circuit: the ball only contains two pixels.
                    # print("")
                    break
    return finder


def selective_search(screen, ball, point, rn_tol, quadrant):
    """Helper function for directional_search."""
    """These for loops use max and min to ensure the search doesn't leave the
        score area. The rn_tol is used to control the radius of the search."""
    if quadrant == 4:
        """These for loops use max and min to ensure the search doesn't leave the
                score area. The rn_tol is used to control the radius of the search."""
        for i in range(max(0, point[0] - 1), min(79, point[0] + rn_tol)):
            for j in range(max(10, point[1] - 1), min(70, point[1] + rn_tol)):
                if screen[i][j] != 0:
                    ball.append((i, j))
                    # print("q4", i, j)
                if len(ball) >= 2:  # Short Circuit: the ball only contains two pixels.
                    break
    elif quadrant == 3:
        for i in range(max(0, point[0] - 1), min(79, point[0] + rn_tol)):
            for j in range(max(10, point[1] - rn_tol), min(70, point[1] + 1)):
                if screen[i][j] != 0:
                    ball.append((i, j))
                    # print("q3", i, j)
                if len(ball) >= 2:
                    break

    elif quadrant == 2:
        for i in range(max(0, point[0] - rn_tol), min(79, point[0] + 1)):
            for j in range(max(10, point[1] - rn_tol), min(70, point[1] + 1)):
                if screen[i][j] != 0:
                    ball.append((i, j))
                    # print("q2", i, j)
                if len(ball) >= 2:
                    break

    elif quadrant == 1:
        for i in range(max(0, point[0] - rn_tol), min(79, point[0] + 1)):
            for j in range(max(10, point[1] - 1), min(70, point[1] + rn_tol)):
                if screen[i][j] != 0:
                    ball.append((i, j))
                    # print("q1", i, j)

                if len(ball) >= 2:
                    break
    else:
        print("malformed quadrant")
        return omni_search(screen, point, ball, rn_tol)

    return len(ball) > 0


def directional_search(screen, ball_list, ball, rn_tol, p_ball, direction):
    """Given two previous locations, infers a direction of travel and
    a search pattern. selective_search will append the points to the ball list."""
    point = forty_close(ball_list)
    directions = travel_vector(point, forty_close(p_ball))  # Returns deltaV, deltaH
    
    # Keep in mind (0, 0) is at top left corner of screen
    if directions[0] >= 0 and directions[1] >= 0:  # Quadrant IV/down-right
        if directions[0] == 0:  # if vertical-coordinate is same while moving right
            direction[0] = 'E' #3
        else:
            direction[0] = 'SE' #3
        finder = selective_search(screen, ball, point, rn_tol, 4)
        
    elif directions[0] >= 0:  # and directions[1] < 0:  # Quadrant III/down-left
        direction[0] = 'SW' # 3
        finder = selective_search(screen, ball, point, rn_tol, 3)
        
    elif directions[0] < 0 and directions[1] >= 0:  # Quadrant I/up-right
        direction[0] = 'NE' #2
        finder = selective_search(screen, ball, point, rn_tol, 1)
        
    elif directions[0] < 0:  # and directions[1] < 0:  # Quadrant II/up-left
        direction[0] = 'NW' #2
        finder = selective_search(screen, ball, point, rn_tol, 2)
        
    else:
        print("dir search error")
        finder = False

    return finder


def ball_track(screen, ball_list, ball, rn_tol, p_ball, direction):
    """Tracks the ball. Determines proximity to lossy areas, and uses that
    information to determine the search pattern."""
    paddle_prox, wall_prox = proximity_alarm(ball_list, rn_tol)
    if paddle_prox or wall_prox or not p_ball:  # Ball is near lossy area or no direction has been established

        test = omni_search(screen, ball_list, ball, rn_tol)
    else:
        test = directional_search(screen, ball_list, ball, rn_tol, p_ball, direction)

    return test


#
# geoff: three possible ways of returning a direction
#  1. ball is not tracked; 2. ball_track(); 3. get_ball();
#
def get_ball(screen, ball_list, rn_tol, p_ball, initial=False):
    """Scans for the ball. If no previous location is provided, it searches the center, then the entire field.
    ball_list is the ball in the last frame, p_ball is two frames past"""
    global proximity, check
    ball = list()
    direction = [0]

    if (-1, -1) in ball_list:  # ball is not tracked, no scan
        ball.append((-1, -1))
        return ball, direction  # direction[0] = 0

    elif initial:  # Search center field
        if not ball_list:  # Haven't found the ball in initial stages.
            finder = center_search(screen, ball)
        else:  # Have found the ball, continue tracking
            finder = ball_track(screen, ball_list, ball, rn_tol, p_ball, direction)


    elif not ball_list:  # no ball, check last known position
        if p_ball:
            ball, direction = get_ball(screen, p_ball, rn_tol, p_ball)

        elif proximity:  # Proximity variable is triggered in lossy areas.
            check += 1
            if check >= 4:
                proximity = False  # Short the proximity var to prevent wasted computation.
            # print("Edge scan")
            return edge_scan(screen), [0]   # i.e., direction = [0]

        else:
            ball.append((-1, -1))
            return ball, direction

    else:  # Something is in the ball_list, attempt to trace new location
        check = 0
        finder = ball_track(screen, ball_list, ball, rn_tol, p_ball, direction)

    return ball, direction


def edge_scan(screen):  # up/down, left/right paddle is xx, 70 xx, 71
    """Hard coded values that represent the edges of the playing field,  top
    to bottom and left to right, stopping at the paddles."""

    found = list()
    for j in range(10, 70):
        for i in range(0, 6):
            if screen[i][j] != 0:
                found.append((i, j))
        for i in range(75, 80):
            if screen[i][j] != 0:
                found.append((i, j))

    for i in range(6, 75):
        for j in range(10, 16):
            if screen[i][j] != 0:
                found.append((i, j))
        for j in range(64, 70):
            if screen[i][j] != 0:
                found.append((i, j))
    return found


def full_scan(screen, remove_paddles=True):
    """Unused, for debugging. Brute force searches the entire field for pixels.
    Expensive."""
    pixel_list = list()
    for i in range(len(screen)):
        for j in range(len(screen[i])):
            if screen[i][j] != 0:
                if remove_paddles:
                    if j not in [8, 9, 70, 71]:
                        pixel_list.append((i, j))
                else:
                    pixel_list.append((i, j))
    return pixel_list


def get_left_paddle(screen, paddle_list):
    """Searches the two columns of pixels for the left paddle."""
    l_paddle = list()
    # if not paddle_list:
    for m in range(0, 79):
        # for k in range(8, 10):
        if screen[m][8] != 0:
            for n in range(m, m + 8):
                # l_paddle.append((n, 8))
                l_paddle.append((n, 9))
            break
    return l_paddle


def get_right_paddle(screen, paddle_list):
    """Searches the two columns of pixels for the right paddle. Not
    currently used by any function."""
    r_paddle = list()
    # if not paddle_list:
    for m in range(0, 79):
        # for j in range(70, 72):
        if screen[m][70] != 0:
            for n in range(m, m + 8):
                r_paddle.append((n, 70))
                # r_paddle.append((n, 71))
            break
    return r_paddle
    
def forty_close(elotup):
    """Used to find the closest pixel in a list to the center (40, 40) pixel of screen;
    used to separate the paddle pixels from the ball pixels by gauging their distance
    from the center. The only way for the paddle to be closer to the center of the map
    is if it's past either paddle."""
    distance = 100
    closest = (0, 0)
    for tup in elotup:
        if abs(tup[1] - 40) < distance:
            closest = tup
            distance = abs(tup[1] - 40)
    # if closest == (0, 0) and elotup:
        # print(elotup)
        #print("waflgarbl")
        # input("")

    return closest
    
